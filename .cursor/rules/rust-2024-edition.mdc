---
description: Rust 2024 edition best practices and coding standards
alwaysApply: false
---
# Rust 2024 Edition Best Practices

## Основы Rust: концепции безопасности памяти

### Система владения (Ownership)

- **Каждое значение в Rust имеет владельца** — переменную, которая за него отвечает
- **У каждого значения может быть только один владелец** одновременно
- **Когда владелец выходит из области видимости, значение удаляется**

```rust
fn main() {
    let s1 = String::from("hello");  // s1 владеет данными
    let s2 = s1;                     // владение перемещается к s2
    // println!("{s1}");             // ОШИБКА: s1 больше не действительна
    println!("{s2}");                // Только s2 имеет доступ к данным
}
```

### Заимствование (Borrowing)

- **Неизменяемые ссылки (`&T`)** — можно иметь множество одновременно
- **Изменяемые ссылки (`&mut T`)** — может быть только одна
- **Либо одна изменяемая ссылка, либо любое количество неизменяемых**
- **Ссылки должны всегда быть валидными** — никаких висячих указателей

### Новые возможности Rust 2024 edition

#### Улучшенная область временных значений

```rust
use std::sync::RwLock;

fn f(value: &RwLock<Option<bool>>) {
    if let Some(x) = *value.read().unwrap() {
        println!("value is {x}");
    } // <--- В Rust 2024 блокировка чтения снимается здесь
    else {
        let mut s = value.write().unwrap();  // Теперь работает!
        if s.is_none() {
            *s = Some(true);
        }
    }
}
```

#### Новый синтаксис `&raw`

```rust
#[repr(packed)]
struct MyPackedStruct {
    field_a: i32,
    field_b: u8,
}

fn main() {
    let mps = MyPackedStruct { field_a: 42, field_b: 1 };

    // Безопасно в Rust 2024
    let good: *const i32 = &raw const mps.field_a;
    let value: i32 = unsafe { good.read_unaligned() };
}
```

## Rust идиомы и лучшие практики

### Использование типов для выражения намерений

```rust
// Плохо
fn process(s: String) -> String {
    s.to_uppercase()
}

// Хорошо
fn process(s: &str) -> String {
    s.to_uppercase()
}
```

### Эргономичная работа с `Result` и `Option`

```rust
use std::fs::File;
use std::io::Read;

fn read_username_from_file() -> Result<String, std::io::Error> {
    let mut file = File::open("username.txt")?;  // Возвращает ошибку автоматически
    let mut username = String::new();
    file.read_to_string(&mut username)?;         // То же самое здесь
    Ok(username)
}
```

### Эффективная работа с итераторами

```rust
let numbers: Vec<i32> = vec![1, 2, 3, 4, 5];

// Цепочка операций выполняется за один проход
let result: Vec<i32> = numbers
    .iter()
    .filter(|&&x| x % 2 == 0)      // Только четные
    .map(|&x| x * x)               // Квадрат
    .collect();                     // Собираем в вектор
```

## Тестирование в Rust

### Unit-тесты

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_positive_numbers() {
        assert_eq!(add(2, 3), 5);
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_overflow() {
        add(i32::MAX, 1);  // Должно вызвать панику
    }
}
```

### Property-based тестирование

```rust
#[cfg(test)]
mod tests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn test_sort_preserves_length(mut vec: Vec<i32>) {
            let original_len = vec.len();
            vec.sort();
            assert_eq!(vec.len(), original_len);
        }
    }
}
```

## Многопоточность и конкурентность

### Arc и Mutex для разделяемого изменяемого состояния

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());  // Result: 10
}
```

### Async/await для асинхронного программирования

```rust
use tokio;

#[tokio::main]
async fn main() {
    let result = fetch_data().await;
    match result {
        Ok(data) => println!("Data: {}", data),
        Err(e) => eprintln!("Error: {}", e),
    }
}

async fn fetch_data() -> Result<String, reqwest::Error> {
    let response = reqwest::get("https://api.example.com/data")
        .await?
        .text()
        .await?;
    Ok(response)
}
```

## Оптимизация производительности

### Избегайте ненужного клонирования

```rust
// Плохо
fn process_data(data: Vec<String>) -> Vec<String> {
    data.clone()  // Ненужное клонирование
}

// Хорошо
fn process_data(data: &[String]) -> Vec<String> {
    data.to_vec()  // Клонируем только когда нужно
}

// Еще лучше - используйте Cow для оптимизации
use std::borrow::Cow;

fn process_data(data: &[String]) -> Cow<[String]> {
    if needs_modification {
        Cow::Owned(data.iter().map(|s| s.to_uppercase()).collect())
    } else {
        Cow::Borrowed(data)  // Заимствуем без клонирования
    }
}
```

### Используйте итераторы вместо циклов

```rust
let numbers = vec![1, 2, 3, 4, 5];

// Быстро - итераторы оптимизируются компилятором
let result: Vec<i32> = numbers
    .iter()
    .filter(|&&n| n % 2 == 0)
    .map(|&n| n * n)
    .collect();
```

## Безопасное программирование

### Минимизация unsafe кода

```rust
// Обертывайте unsafe в безопасные абстракции
pub struct SafeArray<T> {
    ptr: *mut T,
    len: usize,
    capacity: usize,
}

impl<T> SafeArray<T> {
    pub fn get(&self, index: usize) -> Option<&T> {
        if index < self.len {
            Some(unsafe { &*self.ptr.add(index) })  // Проверили границы
        } else {
            None
        }
    }

    pub fn get_unchecked(&self, index: usize) -> &T {
        debug_assert!(index < self.len);  // Проверка в debug режиме
        unsafe { &*self.ptr.add(index) }
    }
}
```

### Валидация входных данных

```rust
pub struct Email(String);

impl Email {
    pub fn new(email: String) -> Result<Email, &'static str> {
        if email.contains('@') && email.len() > 3 {
            Ok(Email(email))
        } else {
            Err("Invalid email format")
        }
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}
```

## Чек-лист перед коммитом

- [ ] Код компилируется без предупреждений (`cargo build`)
- [ ] Все тесты проходят (`cargo test`)
- [ ] Clippy не выдает предупреждений (`cargo clippy`)
- [ ] Код отформатирован (`cargo fmt`)
- [ ] Документация обновлена (`cargo doc`)
- [ ] Нет ненужных зависимостей (`cargo machete`)
- [ ] Безопасность проверена (`cargo audit`)

## Частые ошибки новичков

### Борьба с borrow checker:

```rust
// Плохо - пытаемся изменить вектор во время итерации
let mut vec = vec![1, 2, 3, 4, 5];
for i in 0..vec.len() {
    if vec[i] % 2 == 0 {
        vec.remove(i);  // ОШИБКА
    }
}

// Хорошо - создаем новый вектор
let vec = vec![1, 2, 3, 4, 5];
let vec: Vec<i32> = vec.into_iter().filter(|&x| x % 2 != 0).collect();
```

### Неправильная работа с String:

```rust
// Плохо - лишние аллокации
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

// Хорошо - используем заимствование
fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}
```
