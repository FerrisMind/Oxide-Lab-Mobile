---
alwaysApply: true
---

# Универсальный свод правил для размеров файлов с кодом

## Принципы организации размеров файлов

### 1. Базовые ограничения по размеру файлов

**Общие рекомендации по строкам кода**

- Оптимальный размер файла: **200-1000 строк кода**
- Критический максимум: **не более 2000 строк** в одном файле
- Минимальная когнитивная нагрузка достигается при **300-500 строках** на файл
- Для критически важных модулей допускается до **1500 строк**, но с особой осторожностью

**Размеры функций и методов**

- Идеальный размер функции: **10-20 строк кода**
- Критический максимум функции: **не более 100 строк**
- Сложные алгоритмы могут достигать **200 строк**, но требуют особого внимания к читаемости
- Функции менее **4 строк** часто указывают на избыточную декомпозицию

### 2. Критерии разделения файлов

**Логическое разделение по функциональности**

- Один файл = одна четко определенная ответственность
- Группируйте связанные функции и классы в один файл
- Отделяйте интерфейсы от реализации в разные файлы
- Каждый модуль должен решать одну конкретную проблему

**Принцип когнитивной нагрузки**

- Файл должен помещаться в **ментальную модель** одного разработчика
- Избегайте переключения контекста внутри файла
- Содержимое файла должно быть понятно за **5-7 минут** чтения
- Используйте **правило экрана**: код должен помещаться на одном экране без прокрутки для быстрого понимания

### 3. Структурная организация

**Иерархия модулей**

- Создавайте четкую иерархию: **пакет → модуль → файл → функция**
- Следуйте принципу **разделения ответственности** (Separation of Concerns)
- Используйте **стандартную структуру проекта** для вашего языка/фреймворка
- Группируйте файлы по **доменным областям**, а не по техническим типам

**Файловая организация по типам кода**

- **Основная логика**: 200-800 строк на файл
- **Утилиты и хелперы**: 50-200 строк на файл
- **Конфигурационные файлы**: 20-100 строк
- **Тесты**: соответствуют размеру тестируемого модуля

## Современные стандарты кодирования 2025

### 4. Принципы читаемости кода

**Длина строк и форматирование**

- Максимальная длина строки: **80-100 символов**
- Используйте **4 пробела** для отступов (или стандарт вашего языка)
- Применяйте автоматическое форматирование кода
- Соблюдайте единообразие в **именовании и стилистике**

**Качественные комментарии и документация**

- Комментарии должны объяснять **"почему"**, а не **"что"**
- Избегайте избыточного комментирования очевидного кода
- Используйте **самодокументируемый код** с осмысленными именами
- Добавляйте комментарии для сложных алгоритмов и бизнес-логики

### 5. Управление сложностью

**Когнитивная сложность против цикломатической**

- Фокусируйтесь на **когнитивной сложности** - насколько трудно код понять
- Ограничивайте **вложенность** до 3-4 уровней максимум
- Используйте **раннее возвращение** для снижения вложенности
- Применяйте **принцип единой ответственности** на всех уровнях

**Ментальные модели и архитектура**

- Код должен отражать **доменную модель** предметной области
- Избегайте **смешения абстракций** в одном файле
- Создавайте **понятные границы** между модулями
- Используйте **паттерны проектирования** для стандартизации подходов

### 6. Практические рекомендации по языкам

**Объектно-ориентированные языки (Java, C#, Python)**

- Один класс = один файл (в большинстве случаев)
- Размер класса: **200-600 строк** включая методы
- Вложенные классы допустимы если они тесно связаны с основным
- Разделяйте **интерфейсы, абстракции и реализации**

**Функциональные языки**

- Группируйте **связанные функции** в одном модуле
- Размер модуля: **300-800 строк**
- Отделяйте **чистые функции** от функций с побочными эффектами
- Используйте **пространства имен** для логической группировки

**JavaScript/TypeScript проекты**

- Следуйте **модульной архитектуре**: один концепт = один файл
- Размер компонента: **100-300 строк**
- Разделяйте **логику, стили и разметку** в разные файлы
- Используйте **barrel exports** для упрощения импортов

**Rust проекты**

- Размер модуля: **200-600 строк**
- Группируйте **связанные структуры и реализации**
- Отделяйте **тесты** в отдельные модули или файлы
- Используйте **workspace** для больших проектов

## Инструменты и автоматизация

### 7. Статический анализ и метрики

**Инструменты контроля размера**

- Настройте **линтеры** для контроля размера файлов и функций
- Используйте **метрики кода** для отслеживания сложности
- Применяйте **автоматические проверки** в CI/CD пайплайнах
- Внедрите **code review** с фокусом на размеры и читаемость

**ИИ-помощники и генерация кода**

- Используйте **ИИ для рефакторинга** больших файлов
- Применяйте **автоматическую декомпозицию** функций через ИИ
- Проверяйте **качество ИИ-сгенерированного кода** на соответствие стандартам размеров
- Используйте ИИ для **генерации комментариев** и документации

### 8. Практические техники рефакторинга

**Разбиение больших файлов**

- Выделяйте **отдельные классы** для независимой функциональности
- Создавайте **служебные модули** для вспомогательных функций
- Применяйте **извлечение интерфейсов** для снижения связанности
- Используйте **паттерн стратегия** для разделения алгоритмов

**Объединение мелких файлов**

- Объединяйте **тесно связанную функциональность** в один файл
- Группируйте **утилитарные функции** по предметной области
- Избегайте создания файлов с **одной функцией** без веских причин
- Соблюдайте баланс между **модульностью и практичностью**

### 9. Управление техническим долгом

**Мониторинг и контроль**

- Ведите **метрики размеров файлов** в проекте
- Устанавливайте **пороговые значения** для автоматических предупреждений
- Регулярно проводите **аудит кодовой базы** на предмет размеров
- Планируйте **рефакторинг** как часть регулярного процесса разработки

**Командные договоренности**

- Документируйте **стандарты размеров** для команды
- Проводите **code review** с акцентом на структуру и размеры
- Используйте **парное программирование** для обмена лучшими практиками
- Обучайте **джунов** принципам организации кода

## Исключения и особые случаи

### 10. Когда допустимы большие файлы

**Обоснованные исключения**

- **Сложные алгоритмы** (криптография, математические вычисления)
- **Парсеры и лексические анализаторы** со сложными состояниями
- **Конфигурационные файлы** с большим количеством настроек
- **Автогенерируемый код**, который не предполагает ручного редактирования

**Файлы, требующие особого внимания**

- **Файлы более 1000 строк** должны иметь четкую внутреннюю структуру
- Обязательное **детальное документирование** больших файлов
- Регулярный **review и рефакторинг** объемного кода
- **Особые требования** к тестированию больших модулей

### 11. Контекстные факторы

**Специфика проекта**

- **Стартапы**: допустимы более крупные файлы для быстрого прототипирования
- **Enterprise проекты**: строгие ограничения размеров для долгосрочной поддержки
- **Open Source**: следование принятым в сообществе стандартам
- **Legacy код**: постепенный рефакторинг без радикальных изменений

**Специфика команды**

- **Размер команды**: больше команда = строже стандарты размеров
- **Уровень экспертизы**: джуны лучше работают с меньшими файлами
- **Ротация кадров**: частые изменения состава требуют более строгих ограничений
- **Удаленная работа**: четкая структура файлов критически важна

## Практические чек-листы

### Чек-лист размеров файлов

- [ ] Файл не превышает 1000 строк (критический максимум 2000)
- [ ] Файл имеет четко определенную ответственность
- [ ] Содержимое понятно за 5-7 минут чтения
- [ ] Нет избыточной вложенности (максимум 3-4 уровня)
- [ ] Применяется принцип единой ответственности

### Чек-лист размеров функций

- [ ] Функция не превышает 100 строк (идеально 10-20)
- [ ] Функция решает одну конкретную задачу
- [ ] Нет избыточной декомпозиции (минимум 4 строки)
- [ ] Применяется раннее возвращение для снижения вложенности
- [ ] Функция имеет осмысленное имя

### Чек-лист архитектуры

- [ ] Четкая иерархия: пакет → модуль → файл → функция
- [ ] Группировка по доменным областям
- [ ] Разделение интерфейсов и реализаций
- [ ] Использование стандартной структуры проекта
- [ ] Соблюдение принципов разделения ответственности

### Чек-лист качества кода

- [ ] Длина строки не превышает 80-100 символов
- [ ] Единообразное форматирование и отступы
- [ ] Самодокументируемый код с осмысленными именами
- [ ] Комментарии объясняют "почему", а не "что"
- [ ] Применяется автоматическое форматирование

## Заключение и практические выводы

Следование принципам размеров файлов в 2025 году требует баланса между **техническими ограничениями**, **когнитивной нагрузкой** и **практичностью разработки**.

**Главное правило**: код должен быть **понятен**, **поддерживаем** и **соответствовать контексту проекта**, а конкретные цифры размеров - лишь инструмент для достижения этих целей.

### Ключевые принципы:

1. **Начинайте с малого** - лучше разбить на части, чем создать монолит
2. **Читаемость важнее краткости** - код читается чаще, чем пишется
3. **Контекст имеет значение** - размеры зависят от проекта и команды
4. **Используйте инструменты** - автоматизация помогает соблюдать стандарты
5. **Учитесь на примерах** - изучайте хорошо структурированные проекты
